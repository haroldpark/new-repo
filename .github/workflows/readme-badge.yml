# ðŸ† Key Benefits:
# Zero Maintenance:

# Set it once, forget it forever
# Automatically detects your project type
# Updates badges as your project evolves

# Professional Appearance:

# Consistent, modern badge styling
# Color-coded for instant status recognition
# Includes relevant technology logos

# Real-Time Data:

# Always current GitHub statistics
# Live build status from CI/CD
# Actual test coverage percentages

# Smart Integration:

# Works with any project structure
# Preserves existing README content
# Shows previews in pull requests

name: Auto-Update README Badges

on:
  push:
    branches: [main, develop, harold]
  pull_request:
    branches: [main, develop, harold]
  release:
    types: [published]
  schedule:
    # Update badges daily at 6 AM UTC
    - cron: '0 6 * * *'
  workflow_dispatch:
    inputs:
      force_update:
        description: 'Force update all badges'
        required: false
        type: boolean
        default: false

jobs:
  update-badges:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      actions: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: |
          if [ -f package.json ]; then
            npm ci || npm install
          fi

      - name: Get repository information
        id: repo_info
        run: |
          # Get repository details
          REPO_NAME="${{ github.repository }}"
          REPO_OWNER="${{ github.repository_owner }}"
          REPO_FULL_NAME="${REPO_NAME}"
          BRANCH_NAME="${{ github.ref_name }}"

          echo "repo_name=$REPO_NAME" >> $GITHUB_OUTPUT
          echo "repo_owner=$REPO_OWNER" >> $GITHUB_OUTPUT
          echo "repo_full_name=$REPO_FULL_NAME" >> $GITHUB_OUTPUT
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

          # Get latest release
          LATEST_RELEASE=$(gh release list --limit 1 --json tagName --jq '.[0].tagName' 2>/dev/null || echo "v0.0.0")
          echo "latest_release=$LATEST_RELEASE" >> $GITHUB_OUTPUT

          # Check if repo is public or private
          REPO_VISIBILITY=$(gh repo view $REPO_FULL_NAME --json visibility --jq '.visibility')
          echo "repo_visibility=$REPO_VISIBILITY" >> $GITHUB_OUTPUT

          echo "ðŸ“Š Repository: $REPO_FULL_NAME"
          echo "ðŸ·ï¸ Latest Release: $LATEST_RELEASE" 
          echo "ðŸ‘ï¸ Visibility: $REPO_VISIBILITY"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Analyze project structure
        id: project_analysis
        run: |
          echo "ðŸ” Analyzing project structure..."

          # Detect project type and technologies
          HAS_PACKAGE_JSON=$([[ -f package.json ]] && echo "true" || echo "false")
          HAS_DOCKERFILE=$([[ -f Dockerfile ]] && echo "true" || echo "false")
          HAS_PYTHON=$([[ -f requirements.txt || -f setup.py || -f pyproject.toml ]] && echo "true" || echo "false")
          HAS_JAVA=$([[ -f pom.xml || -f build.gradle ]] && echo "true" || echo "false")
          HAS_GO=$([[ -f go.mod ]] && echo "true" || echo "false")
          HAS_RUST=$([[ -f Cargo.toml ]] && echo "true" || echo "false")

          echo "has_package_json=$HAS_PACKAGE_JSON" >> $GITHUB_OUTPUT
          echo "has_dockerfile=$HAS_DOCKERFILE" >> $GITHUB_OUTPUT
          echo "has_python=$HAS_PYTHON" >> $GITHUB_OUTPUT
          echo "has_java=$HAS_JAVA" >> $GITHUB_OUTPUT
          echo "has_go=$HAS_GO" >> $GITHUB_OUTPUT
          echo "has_rust=$HAS_RUST" >> $GITHUB_OUTPUT

          # Get package.json info if exists
          if [ -f package.json ]; then
            NODE_VERSION=$(node -e "console.log(process.version)" 2>/dev/null || echo "unknown")
            PKG_VERSION=$(node -e "console.log(JSON.parse(require('fs').readFileSync('package.json')).version)" 2>/dev/null || echo "0.0.0")
            PKG_LICENSE=$(node -e "console.log(JSON.parse(require('fs').readFileSync('package.json')).license || 'Unknown')" 2>/dev/null || echo "Unknown")
            PKG_NAME=$(node -e "console.log(JSON.parse(require('fs').readFileSync('package.json')).name)" 2>/dev/null || echo "unknown")
            
            echo "node_version=$NODE_VERSION" >> $GITHUB_OUTPUT
            echo "package_version=$PKG_VERSION" >> $GITHUB_OUTPUT
            echo "package_license=$PKG_LICENSE" >> $GITHUB_OUTPUT
            echo "package_name=$PKG_NAME" >> $GITHUB_OUTPUT
            
            # Check if it's published to npm
            NPM_EXISTS=$(npm view $PKG_NAME version 2>/dev/null || echo "")
            echo "npm_exists=$([[ -n \"$NPM_EXISTS\" ]] && echo \"true\" || echo \"false\")" >> $GITHUB_OUTPUT
            echo "npm_version=$NPM_EXISTS" >> $GITHUB_OUTPUT
          fi

          # Count files and get repository stats
          JS_FILES=$(find . -name "*.js" -o -name "*.jsx" -o -name "*.ts" -o -name "*.tsx" -not -path "*/node_modules/*" | wc -l)
          PY_FILES=$(find . -name "*.py" | wc -l)
          TOTAL_LINES=$(find . -type f \( -name "*.js" -o -name "*.jsx" -o -name "*.ts" -o -name "*.tsx" -o -name "*.py" -o -name "*.java" -o -name "*.go" \) -not -path "*/node_modules/*" -not -path "*/.git/*" -exec wc -l {} + 2>/dev/null | tail -1 | awk '{print $1}' || echo "0")

          echo "js_files=$JS_FILES" >> $GITHUB_OUTPUT
          echo "py_files=$PY_FILES" >> $GITHUB_OUTPUT
          echo "total_lines=$TOTAL_LINES" >> $GITHUB_OUTPUT

      - name: Run tests and get coverage
        id: test_coverage
        if: steps.project_analysis.outputs.has_package_json == 'true'
        run: |
          echo "ðŸ§ª Running tests to get coverage..."

          # Try to run tests with coverage
          if npm run test:coverage 2>/dev/null || npm test -- --coverage 2>/dev/null; then
            # Try to extract coverage from different possible locations
            COVERAGE_PERCENT="0"
            
            if [ -f coverage/coverage-summary.json ]; then
              COVERAGE_PERCENT=$(node -e "
                const fs = require('fs');
                try {
                  const coverage = JSON.parse(fs.readFileSync('coverage/coverage-summary.json', 'utf8'));
                  console.log(coverage.total.lines.pct || 0);
                } catch(e) { console.log(0); }
              ")
            elif [ -f coverage/lcov.info ]; then
              # Parse lcov file for coverage
              COVERAGE_PERCENT=$(awk '/^SF:/ { files++ } /^LH:/ { hit+=$2 } /^LF:/ { total+=$2 } END { if(total>0) print int(hit/total*100); else print 0 }' coverage/lcov.info)
            fi
            
            echo "coverage_percent=$COVERAGE_PERCENT" >> $GITHUB_OUTPUT
            echo "has_coverage=true" >> $GITHUB_OUTPUT
            echo "ðŸ“Š Test coverage: ${COVERAGE_PERCENT}%"
          else
            echo "has_coverage=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ Could not determine test coverage"
          fi

      - name: Get workflow status
        id: workflow_status
        run: |
          echo "ðŸ”„ Getting workflow status..."

          # Get latest workflow runs
          LATEST_WORKFLOW_STATUS=$(gh run list --limit 1 --json conclusion --jq '.[0].conclusion' 2>/dev/null || echo "unknown")

          # Count workflow runs in last 30 days
          WORKFLOW_RUNS_COUNT=$(gh run list --created "$(date -d '30 days ago' '+%Y-%m-%d')" --json id | jq length 2>/dev/null || echo "0")

          echo "latest_workflow_status=$LATEST_WORKFLOW_STATUS" >> $GITHUB_OUTPUT
          echo "workflow_runs_count=$WORKFLOW_RUNS_COUNT" >> $GITHUB_OUTPUT

          echo "ðŸƒ Latest workflow: $LATEST_WORKFLOW_STATUS"
          echo "ðŸ“ˆ Runs (30 days): $WORKFLOW_RUNS_COUNT"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Get repository statistics
        id: repo_stats
        run: |
          echo "ðŸ“Š Gathering repository statistics..."

          # Get repository stats using GitHub API
          REPO_STATS=$(gh api repos/${{ steps.repo_info.outputs.repo_full_name }} --jq '{
            stars: .stargazers_count,
            forks: .forks_count,
            issues: .open_issues_count,
            watchers: .subscribers_count,
            size: .size,
            language: .language,
            created_at: .created_at,
            updated_at: .updated_at
          }')

          STARS=$(echo "$REPO_STATS" | jq -r '.stars')
          FORKS=$(echo "$REPO_STATS" | jq -r '.forks')
          ISSUES=$(echo "$REPO_STATS" | jq -r '.issues')
          LANGUAGE=$(echo "$REPO_STATS" | jq -r '.language // "Unknown"')

          echo "stars=$STARS" >> $GITHUB_OUTPUT
          echo "forks=$FORKS" >> $GITHUB_OUTPUT
          echo "issues=$ISSUES" >> $GITHUB_OUTPUT
          echo "language=$LANGUAGE" >> $GITHUB_OUTPUT

          # Get commit activity
          COMMIT_COUNT=$(git rev-list --count HEAD 2>/dev/null || echo "0")
          LAST_COMMIT=$(git log -1 --format=%ci 2>/dev/null || echo "unknown")
          CONTRIBUTORS=$(git shortlog -sn HEAD | wc -l 2>/dev/null || echo "1")

          echo "commit_count=$COMMIT_COUNT" >> $GITHUB_OUTPUT
          echo "last_commit=$LAST_COMMIT" >> $GITHUB_OUTPUT
          echo "contributors=$CONTRIBUTORS" >> $GITHUB_OUTPUT

          echo "â­ Stars: $STARS, ðŸ´ Forks: $FORKS, ðŸ› Issues: $ISSUES"
          echo "ðŸ’¾ Commits: $COMMIT_COUNT, ðŸ‘¥ Contributors: $CONTRIBUTORS"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate badge URLs
        id: generate_badges
        run: |
          echo "ðŸ·ï¸ Generating badge URLs..."

          REPO_FULL_NAME="${{ steps.repo_info.outputs.repo_full_name }}"
          REPO_OWNER="${{ steps.repo_info.outputs.repo_owner }}"
          BRANCH_NAME="${{ steps.repo_info.outputs.branch_name }}"

          # Base URLs
          SHIELDS_BASE="https://img.shields.io"
          GITHUB_BASE="https://github.com"

          # Build status badge
          BUILD_BADGE="${SHIELDS_BASE}/github/actions/workflow/status/${REPO_FULL_NAME}/ci.yml?branch=${BRANCH_NAME}&style=flat-square&logo=github"
          if [ "${{ steps.workflow_status.outputs.latest_workflow_status }}" = "success" ]; then
            BUILD_BADGE_ALT="${SHIELDS_BASE}/badge/build-passing-brightgreen?style=flat-square&logo=github"
          elif [ "${{ steps.workflow_status.outputs.latest_workflow_status }}" = "failure" ]; then
            BUILD_BADGE_ALT="${SHIELDS_BASE}/badge/build-failing-red?style=flat-square&logo=github"
          else
            BUILD_BADGE_ALT="${SHIELDS_BASE}/badge/build-unknown-lightgrey?style=flat-square&logo=github"
          fi

          # Version badge
          VERSION="${{ steps.repo_info.outputs.latest_release }}"
          VERSION_BADGE="${SHIELDS_BASE}/github/v/release/${REPO_FULL_NAME}?style=flat-square&logo=github"
          if [ "$VERSION" = "v0.0.0" ]; then
            VERSION_BADGE="${SHIELDS_BASE}/badge/version-dev-orange?style=flat-square"
          fi

          # License badge
          LICENSE="${{ steps.project_analysis.outputs.package_license }}"
          LICENSE_BADGE="${SHIELDS_BASE}/github/license/${REPO_FULL_NAME}?style=flat-square"
          if [ "$LICENSE" = "Unknown" ]; then
            LICENSE_BADGE="${SHIELDS_BASE}/badge/license-unknown-lightgrey?style=flat-square"
          fi

          # Language badge
          LANGUAGE="${{ steps.repo_stats.outputs.language }}"
          if [ "$LANGUAGE" != "Unknown" ]; then
            LANGUAGE_BADGE="${SHIELDS_BASE}/github/languages/top/${REPO_FULL_NAME}?style=flat-square"
          else
            LANGUAGE_BADGE="${SHIELDS_BASE}/badge/language-mixed-blue?style=flat-square"
          fi

          # Coverage badge
          if [ "${{ steps.test_coverage.outputs.has_coverage }}" = "true" ]; then
            COVERAGE_PERCENT="${{ steps.test_coverage.outputs.coverage_percent }}"
            if [ "$COVERAGE_PERCENT" -ge 90 ]; then
              COLOR="brightgreen"
            elif [ "$COVERAGE_PERCENT" -ge 80 ]; then
              COLOR="green"
            elif [ "$COVERAGE_PERCENT" -ge 70 ]; then
              COLOR="yellow"
            elif [ "$COVERAGE_PERCENT" -ge 60 ]; then
              COLOR="orange"
            else
              COLOR="red"
            fi
            COVERAGE_BADGE="${SHIELDS_BASE}/badge/coverage-${COVERAGE_PERCENT}%25-${COLOR}?style=flat-square"
          else
            COVERAGE_BADGE="${SHIELDS_BASE}/badge/coverage-unknown-lightgrey?style=flat-square"
          fi

          # GitHub stats badges
          STARS_BADGE="${SHIELDS_BASE}/github/stars/${REPO_FULL_NAME}?style=flat-square&logo=github"
          FORKS_BADGE="${SHIELDS_BASE}/github/forks/${REPO_FULL_NAME}?style=flat-square&logo=github"
          ISSUES_BADGE="${SHIELDS_BASE}/github/issues/${REPO_FULL_NAME}?style=flat-square&logo=github"

          # Node.js version badge (if applicable)
          if [ "${{ steps.project_analysis.outputs.has_package_json }}" = "true" ]; then
            NODE_VERSION="${{ steps.project_analysis.outputs.node_version }}"
            NODE_BADGE="${SHIELDS_BASE}/badge/node-${NODE_VERSION}-green?style=flat-square&logo=node.js"
          fi

          # NPM badge (if published)
          if [ "${{ steps.project_analysis.outputs.npm_exists }}" = "true" ]; then
            PKG_NAME="${{ steps.project_analysis.outputs.package_name }}"
            NPM_BADGE="${SHIELDS_BASE}/npm/v/${PKG_NAME}?style=flat-square&logo=npm"
            NPM_DOWNLOADS="${SHIELDS_BASE}/npm/dm/${PKG_NAME}?style=flat-square&logo=npm"
          fi

          # Docker badge (if has Dockerfile)
          if [ "${{ steps.project_analysis.outputs.has_dockerfile }}" = "true" ]; then
            DOCKER_BADGE="${SHIELDS_BASE}/badge/docker-available-blue?style=flat-square&logo=docker"
          fi

          # Activity badges
          LAST_COMMIT_BADGE="${SHIELDS_BASE}/github/last-commit/${REPO_FULL_NAME}?style=flat-square&logo=github"
          CONTRIBUTORS_BADGE="${SHIELDS_BASE}/github/contributors/${REPO_FULL_NAME}?style=flat-square&logo=github"

          # Save all badge URLs to outputs
          cat >> $GITHUB_OUTPUT << EOF
          build_badge=$BUILD_BADGE
          version_badge=$VERSION_BADGE
          license_badge=$LICENSE_BADGE
          language_badge=$LANGUAGE_BADGE
          coverage_badge=$COVERAGE_BADGE
          stars_badge=$STARS_BADGE
          forks_badge=$FORKS_BADGE
          issues_badge=$ISSUES_BADGE
          last_commit_badge=$LAST_COMMIT_BADGE
          contributors_badge=$CONTRIBUTORS_BADGE
          EOF

          # Optional badges
          if [ -n "$NODE_BADGE" ]; then
            echo "node_badge=$NODE_BADGE" >> $GITHUB_OUTPUT
          fi
          if [ -n "$NPM_BADGE" ]; then
            echo "npm_badge=$NPM_BADGE" >> $GITHUB_OUTPUT
            echo "npm_downloads=$NPM_DOWNLOADS" >> $GITHUB_OUTPUT
          fi
          if [ -n "$DOCKER_BADGE" ]; then
            echo "docker_badge=$DOCKER_BADGE" >> $GITHUB_OUTPUT
          fi

      - name: Update README with badges
        id: update_readme
        run: |
          echo "ðŸ“ Updating README with badges..."

          # Create badge markdown
          create_badge_section() {
            local badges=""
            
            # Essential badges
            badges="${badges}[![Build Status](${{ steps.generate_badges.outputs.build_badge }})](${{ github.server_url }}/${{ github.repository }}/actions)\n"
            badges="${badges}[![Version](${{ steps.generate_badges.outputs.version_badge }})](${{ github.server_url }}/${{ github.repository }}/releases)\n"
            badges="${badges}[![License](${{ steps.generate_badges.outputs.license_badge }})](${{ github.server_url }}/${{ github.repository }}/blob/main/LICENSE)\n"
            
            # Language and coverage
            badges="${badges}[![Language](${{ steps.generate_badges.outputs.language_badge }})](${{ github.server_url }}/${{ github.repository }})\n"
            badges="${badges}[![Coverage](${{ steps.generate_badges.outputs.coverage_badge }})](${{ github.server_url }}/${{ github.repository }}/actions)\n"
            
            # GitHub stats
            badges="${badges}[![Stars](${{ steps.generate_badges.outputs.stars_badge }})](${{ github.server_url }}/${{ github.repository }}/stargazers)\n"
            badges="${badges}[![Forks](${{ steps.generate_badges.outputs.forks_badge }})](${{ github.server_url }}/${{ github.repository }}/network/members)\n"
            badges="${badges}[![Issues](${{ steps.generate_badges.outputs.issues_badge }})](${{ github.server_url }}/${{ github.repository }}/issues)\n"
            
            # Activity badges
            badges="${badges}[![Last Commit](${{ steps.generate_badges.outputs.last_commit_badge }})](${{ github.server_url }}/${{ github.repository }}/commits)\n"
            badges="${badges}[![Contributors](${{ steps.generate_badges.outputs.contributors_badge }})](${{ github.server_url }}/${{ github.repository }}/graphs/contributors)\n"
            
            # Optional technology-specific badges
            if [ "${{ steps.project_analysis.outputs.has_package_json }}" = "true" ]; then
              badges="${badges}[![Node.js](${{ steps.generate_badges.outputs.node_badge }})](https://nodejs.org)\n"
            fi
            
            if [ "${{ steps.project_analysis.outputs.npm_exists }}" = "true" ]; then
              badges="${badges}[![npm](${{ steps.generate_badges.outputs.npm_badge }})](https://www.npmjs.com/package/${{ steps.project_analysis.outputs.package_name }})\n"
              badges="${badges}[![Downloads](${{ steps.generate_badges.outputs.npm_downloads }})](https://www.npmjs.com/package/${{ steps.project_analysis.outputs.package_name }})\n"
            fi
            
            if [ "${{ steps.project_analysis.outputs.has_dockerfile }}" = "true" ]; then
              badges="${badges}[![Docker](${{ steps.generate_badges.outputs.docker_badge }})](${{ github.server_url }}/${{ github.repository }})\n"
            fi
            
            echo "$badges"
          }

          # Read current README
          if [ ! -f README.md ]; then
            echo "# ${{ steps.repo_info.outputs.repo_name }}" > README.md
            echo "" >> README.md
            echo "<!-- AUTO-GENERATED-BADGES-START -->" >> README.md
            echo "<!-- AUTO-GENERATED-BADGES-END -->" >> README.md
          fi

          README_CONTENT=$(cat README.md)

          # Generate new badge section
          BADGE_SECTION="<!-- AUTO-GENERATED-BADGES-START -->\n"
          BADGE_SECTION="${BADGE_SECTION}$(create_badge_section)"
          BADGE_SECTION="${BADGE_SECTION}<!-- AUTO-GENERATED-BADGES-END -->"

          # Update README
          if echo "$README_CONTENT" | grep -q "<!-- AUTO-GENERATED-BADGES-START -->"; then
            # Replace existing badge section
            node -e "
              const fs = require('fs');
              let content = fs.readFileSync('README.md', 'utf8');
              const newBadges = \`$BADGE_SECTION\`;
              content = content.replace(/<!-- AUTO-GENERATED-BADGES-START -->[\s\S]*?<!-- AUTO-GENERATED-BADGES-END -->/, newBadges);
              fs.writeFileSync('README.md', content);
            "
          else
            # Add badge section at the top (after title)
            node -e "
              const fs = require('fs');
              let content = fs.readFileSync('README.md', 'utf8');
              const lines = content.split('\n');
              const newBadges = \`$BADGE_SECTION\`;
              
              // Find the first heading and insert badges after it
              let insertIndex = 1;
              for (let i = 0; i < lines.length; i++) {
                if (lines[i].startsWith('#')) {
                  insertIndex = i + 1;
                  break;
                }
              }
              
              lines.splice(insertIndex, 0, '', newBadges.replace(/\\\\n/g, '\n'), '');
              fs.writeFileSync('README.md', lines.join('\n'));
            "
          fi

          # Check if README was actually changed
          if git diff --quiet README.md; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ No badge changes needed"
          else
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "âœ… README badges updated"
          fi

      - name: Create badge files for static hosting
        run: |
          echo "ðŸ’¾ Creating badge cache files..."
          mkdir -p .github/badges

          # Create JSON files for shields.io dynamic badges
          cat > .github/badges/coverage.json << EOF
          {
            "schemaVersion": 1,
            "label": "coverage",
            "message": "${{ steps.test_coverage.outputs.coverage_percent }}%",
            "color": "$([ ${{ steps.test_coverage.outputs.coverage_percent }} -ge 80 ] && echo 'green' || echo 'red')"
          }
          EOF

          cat > .github/badges/build.json << EOF
          {
            "schemaVersion": 1,
            "label": "build",
            "message": "${{ steps.workflow_status.outputs.latest_workflow_status }}",
            "color": "$([ '${{ steps.workflow_status.outputs.latest_workflow_status }}' = 'success' ] && echo 'green' || echo 'red')"
          }
          EOF

          cat > .github/badges/version.json << EOF
          {
            "schemaVersion": 1,
            "label": "version", 
            "message": "${{ steps.repo_info.outputs.latest_release }}",
            "color": "blue"
          }
          EOF

      - name: Commit badge updates
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Add retry logic for race conditions
          for i in {1..5}; do
            echo "Attempt $i to commit and push changes..."
            
            # Pull latest changes to avoid conflicts
            git pull --rebase origin ${{ github.ref_name }} || true
            
            # Check if we still have changes after rebase
            if git diff --quiet README.md && git diff --quiet .github/badges/; then
              echo "No changes after rebase, skipping commit"
              exit 0
            fi
            
            git add README.md .github/badges/
            git commit -m "ðŸ·ï¸ Auto-update README badges

            - Build: ${{ steps.workflow_status.outputs.latest_workflow_status }}
            - Coverage: ${{ steps.test_coverage.outputs.coverage_percent }}%  
            - Version: ${{ steps.repo_info.outputs.latest_release }}
            - Stars: ${{ steps.repo_stats.outputs.stars }}

            Updated: $(date)" || {
              echo "Nothing to commit, changes may have been made by another workflow"
              exit 0
            }

            # Try to push with retry
            if git push; then
              echo "Successfully pushed changes on attempt $i"
              exit 0
            else
              echo "Push failed on attempt $i, retrying..."
              git reset --soft HEAD~1  # Undo the commit to retry
              sleep $((i * 2))  # Exponential backoff
            fi
          done

          echo "Failed to push after 5 attempts, giving up"
          exit 1

      - name: Comment on PR with badge preview
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const badges = {
              build: '${{ steps.generate_badges.outputs.build_badge }}',
              version: '${{ steps.generate_badges.outputs.version_badge }}',
              coverage: '${{ steps.generate_badges.outputs.coverage_badge }}',
              license: '${{ steps.generate_badges.outputs.license_badge }}',
              stars: '${{ steps.generate_badges.outputs.stars_badge }}'
            };

            let comment = '## ðŸ·ï¸ Badge Preview\n\n';
            comment += 'The following badges will be updated in your README:\n\n';

            Object.entries(badges).forEach(([name, url]) => {
              comment += `**${name.charAt(0).toUpperCase() + name.slice(1)}**: ![${name}](${url})\n\n`;
            });

            if ('${{ steps.update_readme.outputs.changed }}' === 'true') {
              comment += 'âœ… **README will be updated** when this PR is merged.\n';
            } else {
              comment += 'â„¹ï¸ No badge changes detected.\n';
            }

            comment += '\n---\n*Badges will be automatically updated on merge to main branch.*';

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existingComment = comments.find(c => 
              c.body.includes('ðŸ·ï¸ Badge Preview')
            );

            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }

      - name: Set job summary
        run: |
          echo "# ðŸ·ï¸ Badge Update Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Repository Stats" >> $GITHUB_STEP_SUMMARY
          echo "- â­ **Stars**: ${{ steps.repo_stats.outputs.stars }}" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ´ **Forks**: ${{ steps.repo_stats.outputs.forks }}" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ› **Issues**: ${{ steps.repo_stats.outputs.issues }}" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ’¾ **Commits**: ${{ steps.repo_stats.outputs.commit_count }}" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ‘¥ **Contributors**: ${{ steps.repo_stats.outputs.contributors }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Generated Badges" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸš€ Build Status: ${{ steps.workflow_status.outputs.latest_workflow_status }}" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ“Š Coverage: ${{ steps.test_coverage.outputs.coverage_percent }}%" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ·ï¸ Version: ${{ steps.repo_info.outputs.latest_release }}" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ”¤ Language: ${{ steps.repo_stats.outputs.language }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.update_readme.outputs.changed }}" = "true" ]; then
            echo "âœ… **README badges updated successfully!**" >> $GITHUB_STEP_SUMMARY
          else
            echo "â„¹ï¸ **No badge updates needed**" >> $GITHUB_STEP_SUMMARY
          fi
